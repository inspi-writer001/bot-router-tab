{"comment":"Sstan","footnote":"","findings":[{"severity":"Low","title":"Use a locked pragma version instead of a floating pragma version","description":"\"\"\n        Floating pragma is a vulnerability in smart contract code that can cause unexpected behavior by allowing the compiler to use a specified range of versions. \\n This can lead to issues such as using an older compiler version with known vulnerabilities, using a newer compiler version with undiscovered vulnerabilities, inconsistency across files using different versions, or unpredictable behavior because the compiler can use any version within the specified range. It is recommended to use a locked pragma version in order to avoid these potential vulnerabilities. In some cases it may be acceptable to use a floating pragma, such as when a contract is intended for consumption by other developers and needs to be compatible with a range of compiler versions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Bad\n\n        ```js\n            pragma solidity ^0.8.0;\n        ```\n\n        #### Good\n\n        ```js\n            pragma solidity 0.8.15;\n        ```\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["3:pragma solidity ^0.8.0;\n"],"loc":["./src/interfaces/IERC165.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/IPendingOwnable.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/IJoeFactory.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/ILBFlashLoanCallback.sol"]},{"content":["2:pragma solidity ^0.8.10;\n"],"loc":["./src/interfaces/IWNATIVE.sol"]}]},{"severity":"Low","title":"Unsafe ERC20 Operation","description":"\"\"\n        ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard. To account for this, either use OpenZeppelin's SafeERC20 library or wrap each operation in a require statement. \\n\n        > Additionally, ERC20's approve functions have a known race-condition vulnerability. To account for this, use OpenZeppelin's SafeERC20 library's `safeIncrease` or `safeDecrease` Allowance functions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Unsafe Transfer\n\n        ```js\n        IERC20(token).transfer(msg.sender, amount);\n        ```\n\n        #### OpenZeppelin SafeTransfer\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransfer(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe Transfer with require statement.\n\n        ```js\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n                \n        #### Unsafe TransferFrom\n\n        ```js\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        ```\n\n        #### OpenZeppelin SafeTransferFrom\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe TransferFrom with require statement.\n\n        ```js\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["50:        payable(msg.sender).transfer(valueAfterFees);\n"],"loc":["./src/BotRouter.sol"]},{"content":["57:        payable(owner()).transfer(contractBalance);\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"NonCritical","title":"Constructor should check that all parameters are not 0","description":"Consider adding a require statement to check that all parameters are not 0 in the constructor","gasSavings":null,"category":null,"instances":[{"content":["18:    constructor(address _router, address _native, address initialOwner) Ownable(initialOwner) payable {\n"],"loc":["./src/BotRouter.sol"]},{"content":["18:    constructor(address _router, address _native, address initialOwner) Ownable(initialOwner) payable {\n"],"loc":["./src/BotRouter.sol"]},{"content":["18:    constructor(address _router, address _native, address initialOwner) Ownable(initialOwner) payable {\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"NonCritical","title":"This error has no parameters, the state of the contract when the revert occured will not be available","description":"Consider adding parameters to the error to provide more context when a transaction fails","gasSavings":null,"category":null,"instances":[{"content":["11:    error LBPair__ZeroBorrowAmount();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["12:    error LBPair__AddressZero();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["13:    error LBPair__AlreadyInitialized();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["14:    error LBPair__EmptyMarketConfigs();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["15:    error LBPair__FlashLoanCallbackFailed();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["16:    error LBPair__FlashLoanInsufficientAmount();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["17:    error LBPair__InsufficientAmountIn();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["18:    error LBPair__InsufficientAmountOut();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["19:    error LBPair__InvalidInput();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["20:    error LBPair__InvalidStaticFeeParameters();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["21:    error LBPair__OnlyFactory();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["22:    error LBPair__OnlyProtocolFeeRecipient();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["23:    error LBPair__OutOfLiquidity();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["24:    error LBPair__TokenNotSupported();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["28:    error LBPair__MaxTotalFeeExceeded();\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["20:    error LBRouter__SenderIsNotWNATIVE();\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["24:    error LBRouter__BrokenSwapSafetyCheck();\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["25:    error LBRouter__NotFactoryOwner();\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["29:    error LBRouter__LengthsMismatch();\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["30:    error LBRouter__WrongTokenOrder();\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["18:    error LBFactory__AddressZero();\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["25:    error LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["27:    error LBFactory__PresetOpenStateIsAlreadyInTheSameState();\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["32:    error LBFactory__ImplementationNotSet();\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["10:    error LBToken__AddressThisOrZero();\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["11:    error LBToken__InvalidLength();\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["10:    error PendingOwnable__AddressZero();\n"],"loc":["./src/interfaces/IPendingOwnable.sol"]},{"content":["11:    error PendingOwnable__NoPendingOwner();\n"],"loc":["./src/interfaces/IPendingOwnable.sol"]},{"content":["12:    error PendingOwnable__NotOwner();\n"],"loc":["./src/interfaces/IPendingOwnable.sol"]},{"content":["13:    error PendingOwnable__NotPendingOwner();\n"],"loc":["./src/interfaces/IPendingOwnable.sol"]},{"content":["14:    error PendingOwnable__PendingOwnerAlreadySet();\n"],"loc":["./src/interfaces/IPendingOwnable.sol"]}]},{"severity":"NonCritical","title":"Function names should be in camelCase","description":"Ensure that function definitions are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["79:    function initialize(\n80:        uint16 baseFactor,\n81:        uint16 filterPeriod,\n82:        uint16 decayPeriod,\n83:        uint16 reductionFactor,\n84:        uint24 variableFeeControl,\n85:        uint16 protocolShare,\n86:        uint24 maxVolatilityAccumulator,\n87:        uint24 activeId\n88:    ) external;\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["150:    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["154:    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\n155:        external\n156:        returns (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["158:    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n159:        external\n160:        returns (bytes32[] memory amounts);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["244:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["13:    function migrator() external view returns (address);\n"],"loc":["./src/interfaces/IJoeFactory.sol"]},{"content":["169:    function factory() external view returns (address);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["207:    function swap(bool sentTokenY, address to) external returns (uint256 amountXOut, uint256 amountYOut);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["211:    function mint(\n212:        uint256[] calldata ids,\n213:        uint256[] calldata distributionX,\n214:        uint256[] calldata distributionY,\n215:        address to\n216:    ) external returns (uint256 amountXAddedToPair, uint256 amountYAddedToPair, uint256[] memory liquidityMinted);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["218:    function burn(uint256[] calldata ids, uint256[] calldata amounts, address to)\n219:        external\n220:        returns (uint256 amountX, uint256 amountY);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["232:    function initialize(\n233:        IERC20 tokenX,\n234:        IERC20 tokenY,\n235:        uint24 activeId,\n236:        uint16 sampleLifetime,\n237:        bytes32 packedFeeParameters\n238:    ) external;\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["23:    function name() external view returns (string memory);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["25:    function symbol() external view returns (string memory);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["20:    function owner() external view returns (address);\n"],"loc":["./src/interfaces/IPendingOwnable.sol"]},{"content":["33:    function factory() external view returns (address);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["35:    function wavax() external view returns (address);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["167:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["23:    function buy(address _tokenOut, uint256 amountOutMin, uint256 deadline) external payable {\n"],"loc":["./src/BotRouter.sol"]},{"content":["34:    function sell(address _tokenIn, uint256 amountOutMin, uint256 amountInMax, uint256 deadline) external {\n"],"loc":["./src/BotRouter.sol"]},{"content":["6:    function name() external view returns (string memory);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["7:    function symbol() external view returns (string memory);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["8:    function decimals() external view returns (uint8);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["11:    function allowance(address owner, address spender) external view returns (uint);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["13:    function approve(address spender, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["14:    function transfer(address to, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["70:    function MAX_FEE() external pure returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["72:    function MIN_BIN_STEP() external pure returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["74:    function MAX_BIN_STEP() external pure returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["76:    function MAX_PROTOCOL_SHARE() external pure returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["78:    function LBPairImplementation() external view returns (address);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["11:    function deposit() external payable;\n"],"loc":["./src/interfaces/IWNATIVE.sol"]},{"content":["13:    function withdraw(uint256) external;\n"],"loc":["./src/interfaces/IWNATIVE.sol"]},{"content":["10:    function LBFlashLoanCallback(\n11:        address sender,\n12:        IERC20 tokenX,\n13:        IERC20 tokenY,\n14:        bytes32 amounts,\n15:        bytes32 totalFees,\n16:        bytes calldata data\n17:    ) external returns (bytes32);\n"],"loc":["./src/interfaces/ILBFlashLoanCallback.sol"]},{"content":["18:    function name() external view returns (string memory);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["20:    function symbol() external view returns (string memory);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]}]},{"severity":"NonCritical","title":"Consider importing specific identifiers instead of the whole file","description":"This will minimize compiled code size and help with readability","gasSavings":null,"category":null,"instances":[{"content":["4:import \"./IERC165.sol\";\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["3:import \"./interfaces/ILBRouter.sol\";\n"],"loc":["./src/BotRouter.sol"]},{"content":["4:import \"./interfaces/IWNATIVE.sol\";\n"],"loc":["./src/BotRouter.sol"]},{"content":["5:import \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"NonCritical","title":"Function parameters should be in camelCase","description":"Ensure that function parameters are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["187:            uint256 min,\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["188:            uint256 max\n189:        );\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["198:    function findFirstNonEmptyBinId(uint24 id_, bool sentTokenY) external view returns (uint24 id);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["198:    function findFirstNonEmptyBinId(uint24 id_, bool sentTokenY) external view returns (uint24 id);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["200:    function getBin(uint24 id) external view returns (uint256 reserveX, uint256 reserveY);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["202:    function pendingFees(address account, uint256[] memory ids)\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["202:    function pendingFees(address account, uint256[] memory ids)\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["207:    function swap(bool sentTokenY, address to) external returns (uint256 amountXOut, uint256 amountYOut);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["209:    function flashLoan(address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["209:    function flashLoan(address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["209:    function flashLoan(address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["209:    function flashLoan(address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["212:        uint256[] calldata ids,\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["215:        address to\n216:    ) external returns (uint256 amountXAddedToPair, uint256 amountYAddedToPair, uint256[] memory liquidityMinted);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["218:    function burn(uint256[] calldata ids, uint256[] calldata amounts, address to)\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["218:    function burn(uint256[] calldata ids, uint256[] calldata amounts, address to)\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["218:    function burn(uint256[] calldata ids, uint256[] calldata amounts, address to)\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["224:    function collectFees(address account, uint256[] calldata ids) external returns (uint256 amountX, uint256 amountY);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["224:    function collectFees(address account, uint256[] calldata ids) external returns (uint256 amountX, uint256 amountY);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["11:        address sender,\n"],"loc":["./src/interfaces/ILBFlashLoanCallback.sol"]},{"content":["14:        bytes32 amounts,\n"],"loc":["./src/interfaces/ILBFlashLoanCallback.sol"]},{"content":["16:        bytes calldata data\n17:    ) external returns (bytes32);\n"],"loc":["./src/interfaces/ILBFlashLoanCallback.sol"]},{"content":["27:    function totalSupply(uint256 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["29:    function balanceOf(address account, uint256 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["29:    function balanceOf(address account, uint256 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["31:    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["31:    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["36:    function isApprovedForAll(address owner, address spender) external view returns (bool);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["36:    function isApprovedForAll(address owner, address spender) external view returns (bool);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["38:    function approveForAll(address spender, bool approved) external;\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["38:    function approveForAll(address spender, bool approved) external;\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["40:    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["40:    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["40:    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["40:    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["90:    function getFactory() external view returns (ILBFactory factory);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["102:    function getBin(uint24 id) external view returns (uint128 binReserveX, uint128 binReserveY);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["104:    function getNextNonEmptyBin(bool swapForY, uint24 id) external view returns (uint24 nextId);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["129:        returns (uint8 sampleLifetime, uint16 size, uint16 activeSize, uint40 lastUpdated, uint40 firstTimestamp);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["136:    function getPriceFromId(uint24 id) external view returns (uint256 price);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["136:    function getPriceFromId(uint24 id) external view returns (uint256 price);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["138:    function getIdFromPrice(uint256 price) external view returns (uint24 id);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["138:    function getIdFromPrice(uint256 price) external view returns (uint24 id);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["143:        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["148:        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["150:    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["152:    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["152:    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["152:    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["154:    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["158:    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["158:    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["158:    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["160:        returns (bytes32[] memory amounts);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["15:    function getPair(address tokenA, address tokenB) external view returns (address pair);\n"],"loc":["./src/interfaces/IJoeFactory.sol"]},{"content":["17:    function allPairs(uint256) external view returns (address pair);\n"],"loc":["./src/interfaces/IJoeFactory.sol"]},{"content":["21:    function createPair(address tokenA, address tokenB) external returns (address pair);\n"],"loc":["./src/interfaces/IJoeFactory.sol"]},{"content":["115:    function getIdFromPrice(ILBPair LBPair, uint256 price) external view returns (uint24);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["115:    function getIdFromPrice(ILBPair LBPair, uint256 price) external view returns (uint24);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["117:    function getPriceFromId(ILBPair LBPair, uint24 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["117:    function getPriceFromId(ILBPair LBPair, uint24 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["119:    function getSwapIn(ILBPair LBPair, uint128 amountOut, bool swapForY)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["122:        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["124:    function getSwapOut(ILBPair LBPair, uint128 amountIn, bool swapForY)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["127:        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["131:        returns (ILBPair pair);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["162:        uint256[] memory ids,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["163:        uint256[] memory amounts,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["164:        address to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["165:        uint256 deadline\n166:    ) external returns (uint256 amountX, uint256 amountY);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["169:        IERC20 token,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["173:        uint256[] memory ids,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["174:        uint256[] memory amounts,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["175:        address payable to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["176:        uint256 deadline\n177:    ) external returns (uint256 amountToken, uint256 amountNATIVE);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["182:        Path memory path,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["183:        address to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["184:        uint256 deadline\n185:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["190:        Path memory path,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["191:        address payable to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["192:        uint256 deadline\n193:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["195:    function swapExactNATIVEForTokens(uint256 amountOutMin, Path memory path, address to, uint256 deadline)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["195:    function swapExactNATIVEForTokens(uint256 amountOutMin, Path memory path, address to, uint256 deadline)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["195:    function swapExactNATIVEForTokens(uint256 amountOutMin, Path memory path, address to, uint256 deadline)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["203:        Path memory path,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["204:        address to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["205:        uint256 deadline\n206:    ) external returns (uint256[] memory amountsIn);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["211:        Path memory path,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["212:        address payable to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["213:        uint256 deadline\n214:    ) external returns (uint256[] memory amountsIn);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["216:    function swapNATIVEForExactTokens(uint256 amountOut, Path memory path, address to, uint256 deadline)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["216:    function swapNATIVEForExactTokens(uint256 amountOut, Path memory path, address to, uint256 deadline)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["216:    function swapNATIVEForExactTokens(uint256 amountOut, Path memory path, address to, uint256 deadline)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["224:        Path memory path,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["225:        address to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["226:        uint256 deadline\n227:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["232:        Path memory path,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["233:        address payable to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["234:        uint256 deadline\n235:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["239:        Path memory path,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["240:        address to,\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["241:        uint256 deadline\n242:    ) external payable returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["244:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["244:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["244:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["246:    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["246:    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["246:    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n"],"loc":["./src/interfaces/ILBRouter.sol"]},{"content":["82:    function getQuoteAsset(uint256 index) external view returns (IERC20);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["84:    function isQuoteAsset(IERC20 token) external view returns (bool);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["92:    function allLBPairs(uint256 id) external returns (ILBLegacyPair);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["120:        returns (LBPairInformation[] memory LBPairsBinStep);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["122:    function setLBPairImplementation(address LBPairImplementation) external;\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["126:        returns (ILBLegacyPair pair);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["128:    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint256 binStep, bool ignored) external;\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["161:    function setFactoryLockedState(bool locked) external;\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["167:    function forceDecay(ILBLegacyPair LBPair) external;\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["91:    function getLBPairAtIndex(uint256 id) external returns (ILBPair);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["95:    function getQuoteAssetAtIndex(uint256 index) external view returns (IERC20);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["97:    function isQuoteAsset(IERC20 token) external view returns (bool);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["125:        returns (LBPairInformation[] memory LBPairsBinStep);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["131:        returns (ILBPair pair);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["133:    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external;\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["10:    function balanceOf(address owner) external view returns (uint);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["11:    function allowance(address owner, address spender) external view returns (uint);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["11:    function allowance(address owner, address spender) external view returns (uint);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["13:    function approve(address spender, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["13:    function approve(address spender, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["14:    function transfer(address to, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["14:    function transfer(address to, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["15:    function transferFrom(address from, address to, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["15:    function transferFrom(address from, address to, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["15:    function transferFrom(address from, address to, uint value) external returns (bool);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["39:    function getIdFromPrice(ILBLegacyPair LBPair, uint256 price) external view returns (uint24);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["39:    function getIdFromPrice(ILBLegacyPair LBPair, uint256 price) external view returns (uint24);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["41:    function getPriceFromId(ILBLegacyPair LBPair, uint24 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["41:    function getPriceFromId(ILBLegacyPair LBPair, uint24 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["55:        returns (ILBLegacyPair pair);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["72:        uint256[] memory ids,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["73:        uint256[] memory amounts,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["74:        address to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["75:        uint256 deadline\n76:    ) external returns (uint256 amountX, uint256 amountY);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["79:        IERC20 token,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["83:        uint256[] memory ids,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["84:        uint256[] memory amounts,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["85:        address payable to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["86:        uint256 deadline\n87:    ) external returns (uint256 amountToken, uint256 amountAVAX);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["94:        address to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["95:        uint256 deadline\n96:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["103:        address payable to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["104:        uint256 deadline\n105:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["111:        address to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["112:        uint256 deadline\n113:    ) external payable returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["120:        address to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["121:        uint256 deadline\n122:    ) external returns (uint256[] memory amountsIn);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["129:        address payable to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["130:        uint256 deadline\n131:    ) external returns (uint256[] memory amountsIn);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["137:        address to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["138:        uint256 deadline\n139:    ) external payable returns (uint256[] memory amountsIn);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["146:        address to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["147:        uint256 deadline\n148:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["155:        address payable to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["156:        uint256 deadline\n157:    ) external returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["163:        address to,\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["164:        uint256 deadline\n165:    ) external payable returns (uint256 amountOut);\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["167:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["167:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["167:    function sweep(IERC20 token, address to, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["169:    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["169:    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["169:    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n"],"loc":["./src/interfaces/ILBLegacyRouter.sol"]},{"content":["18:    constructor(address _router, address _native, address initialOwner) Ownable(initialOwner) payable {\n"],"loc":["./src/BotRouter.sol"]},{"content":["18:    constructor(address _router, address _native, address initialOwner) Ownable(initialOwner) payable {\n"],"loc":["./src/BotRouter.sol"]},{"content":["23:    function buy(address _tokenOut, uint256 amountOutMin, uint256 deadline) external payable {\n"],"loc":["./src/BotRouter.sol"]},{"content":["34:    function sell(address _tokenIn, uint256 amountOutMin, uint256 amountInMax, uint256 deadline) external {\n"],"loc":["./src/BotRouter.sol"]},{"content":["22:    function balanceOf(address account, uint256 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["22:    function balanceOf(address account, uint256 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["24:    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["24:    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["29:    function totalSupply(uint256 id) external view returns (uint256);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["31:    function isApprovedForAll(address owner, address spender) external view returns (bool);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["31:    function isApprovedForAll(address owner, address spender) external view returns (bool);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["33:    function setApprovalForAll(address sender, bool approved) external;\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["33:    function setApprovalForAll(address sender, bool approved) external;\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["35:    function safeTransferFrom(address from, address to, uint256 id, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["35:    function safeTransferFrom(address from, address to, uint256 id, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["35:    function safeTransferFrom(address from, address to, uint256 id, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["35:    function safeTransferFrom(address from, address to, uint256 id, uint256 amount) external;\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["37:    function safeBatchTransferFrom(address from, address to, uint256[] calldata id, uint256[] calldata amount)\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["37:    function safeBatchTransferFrom(address from, address to, uint256[] calldata id, uint256[] calldata amount)\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["37:    function safeBatchTransferFrom(address from, address to, uint256[] calldata id, uint256[] calldata amount)\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]},{"content":["37:    function safeBatchTransferFrom(address from, address to, uint256[] calldata id, uint256[] calldata amount)\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]}]},{"severity":"Gas","title":"Pack Structs","description":"\n When creating structs, make sure that the variables are listed in ascending order by data type. The compiler will pack the variables that can fit into one 32 byte slot. If the variables are not listed in ascending order, the compiler may not pack the data into one slot, causing additional `sload` and `sstore` instructions when reading/storing the struct into the contract's storage. - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["18:    struct LBPairInformation {\n19:        uint16 binStep;\n20:        ILBLegacyPair LBPair;\n21:        bool createdByOwner;\n22:        bool ignoredForRouting;\n23:    }\n24:\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["41:    struct LBPairInformation {\n42:        uint16 binStep;\n43:        ILBPair LBPair;\n44:        bool createdByOwner;\n45:        bool ignoredForRouting;\n46:    }\n47:\n"],"loc":["./src/interfaces/ILBFactory.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `constant` if they never change.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["11:    address public nativeAvax = address(native);\n"],"loc":["./src/BotRouter.sol"]},{"content":["13:    uint128 public sellFee = 200; // 2% in basis points (parts per 10,000)\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `immutable` if they never change after contract initialization.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. \n - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["9:    IWNATIVE public native;\n"],"loc":["./src/BotRouter.sol"]},{"content":["8:    ILBRouter public router;\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"Gas","title":"Use custom errors instead of string error messages","description":"\n Using custom errors will save you gas, and can be used to provide more information about the error. - Savings: ~57 \n","gasSavings":null,"category":null,"instances":[{"content":["56:        require(contractBalance > 0, \"No funds available for withdrawal.\");\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"Gas","title":"Use assembly for math (add, sub, mul, div)","description":"\n Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow. - Savings: ~60 \n","gasSavings":null,"category":null,"instances":[{"content":["46:        uint256 value = balanceAfter - balanceBefore;\n"],"loc":["./src/BotRouter.sol"]},{"content":["48:        uint256 valueAfterFees = (value * sellFee) / 10_000;\n"],"loc":["./src/BotRouter.sol"]},{"content":["48:        uint256 valueAfterFees = (value * sellFee) / 10_000;\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"Gas","title":"Event is not properly indexed.","description":"\n When possible, always include a minimum of 3 indexed event topics to save gas - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["21:    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n"],"loc":["./src/interfaces/ILBToken.sol"]},{"content":["52:    event FeeRecipientSet(address oldRecipient, address newRecipient);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["54:    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["56:    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["58:    event LBPairIgnoredStateChanged(ILBPair indexed LBPair, bool ignored);\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["60:    event PresetSet(\n61:        uint256 indexed binStep,\n62:        uint256 baseFactor,\n63:        uint256 filterPeriod,\n64:        uint256 decayPeriod,\n65:        uint256 reductionFactor,\n66:        uint256 variableFeeControl,\n67:        uint256 protocolShare,\n68:        uint256 maxVolatilityAccumulator\n69:    );\n"],"loc":["./src/interfaces/ILBFactory.sol"]},{"content":["29:    event FeeRecipientSet(address oldRecipient, address newRecipient);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["31:    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["33:    event FeeParametersSet(\n34:        address indexed sender,\n35:        ILBLegacyPair indexed LBPair,\n36:        uint256 binStep,\n37:        uint256 baseFactor,\n38:        uint256 filterPeriod,\n39:        uint256 decayPeriod,\n40:        uint256 reductionFactor,\n41:        uint256 variableFeeControl,\n42:        uint256 protocolShare,\n43:        uint256 maxVolatilityAccumulator\n44:    );\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["46:    event FactoryLockedStatusUpdated(bool unlocked);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["48:    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["50:    event LBPairIgnoredStateChanged(ILBLegacyPair indexed LBPair, bool ignored);\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["52:    event PresetSet(\n53:        uint256 indexed binStep,\n54:        uint256 baseFactor,\n55:        uint256 filterPeriod,\n56:        uint256 decayPeriod,\n57:        uint256 reductionFactor,\n58:        uint256 variableFeeControl,\n59:        uint256 protocolShare,\n60:        uint256 maxVolatilityAccumulator,\n61:        uint256 sampleLifetime\n62:    );\n"],"loc":["./src/interfaces/ILBLegacyFactory.sol"]},{"content":["7:    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n"],"loc":["./src/interfaces/IJoeFactory.sol"]},{"content":["3:    event Approval(address indexed owner, address indexed spender, uint value);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["4:    event Transfer(address indexed from, address indexed to, uint value);\n"],"loc":["./src/interfaces/IERC20.sol"]},{"content":["145:    event FlashLoan(address indexed sender, address indexed receiver, IERC20 token, uint256 amount, uint256 fee);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["159:    event FeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["161:    event ProtocolFeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["163:    event OracleSizeIncreased(uint256 previousSize, uint256 newSize);\n"],"loc":["./src/interfaces/ILBLegacyPair.sol"]},{"content":["15:    event FundsWithdrawn(uint256 amount);\n"],"loc":["./src/BotRouter.sol"]},{"content":["40:    event CompositionFees(address indexed sender, uint24 id, bytes32 totalFees, bytes32 protocolFees);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["42:    event CollectedProtocolFees(address indexed feeRecipient, bytes32 protocolFees);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["44:    event Swap(\n45:        address indexed sender,\n46:        address indexed to,\n47:        uint24 id,\n48:        bytes32 amountsIn,\n49:        bytes32 amountsOut,\n50:        uint24 volatilityAccumulator,\n51:        bytes32 totalFees,\n52:        bytes32 protocolFees\n53:    );\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["55:    event StaticFeeParametersSet(\n56:        address indexed sender,\n57:        uint16 baseFactor,\n58:        uint16 filterPeriod,\n59:        uint16 decayPeriod,\n60:        uint16 reductionFactor,\n61:        uint24 variableFeeControl,\n62:        uint16 protocolShare,\n63:        uint24 maxVolatilityAccumulator\n64:    );\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["66:    event FlashLoan(\n67:        address indexed sender,\n68:        ILBFlashLoanCallback indexed receiver,\n69:        uint24 activeId,\n70:        bytes32 amounts,\n71:        bytes32 totalFees,\n72:        bytes32 protocolFees\n73:    );\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["75:    event OracleLengthIncreased(address indexed sender, uint16 oracleLength);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["77:    event ForcedDecay(address indexed sender, uint24 idReference, uint24 volatilityReference);\n"],"loc":["./src/interfaces/ILBPair.sol"]},{"content":["16:    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n"],"loc":["./src/interfaces/ILBLegacyToken.sol"]}]},{"severity":"Gas","title":"Mark functions as payable (with discretion)","description":"\n You can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether. - Savings: ~24 \n","gasSavings":null,"category":null,"instances":[{"content":["34:    function sell(address _tokenIn, uint256 amountOutMin, uint256 amountInMax, uint256 deadline) external {\n"],"loc":["./src/BotRouter.sol"]},{"content":["53:    function withdrawFees() external onlyOwner {\n"],"loc":["./src/BotRouter.sol"]}]},{"severity":"Gas","title":"Use assembly when getting a contract's balance of ETH","description":"\n You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH. - Savings: ~15 \n","gasSavings":null,"category":null,"instances":[{"content":["41:        uint256 balanceBefore = address(this).balance;\n"],"loc":["./src/BotRouter.sol"]},{"content":["44:        uint256 balanceAfter = address(this).balance;\n"],"loc":["./src/BotRouter.sol"]},{"content":["55:        uint256 contractBalance = address(this).balance;\n"],"loc":["./src/BotRouter.sol"]}]}]}